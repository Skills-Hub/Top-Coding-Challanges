## Things we do 
As computer programmer we write code to perform various types of activities and here are my 100 things we do 

1. **Variable Initialization**: Setting up the initial state of a variable.
2. **Value Assignment**: Defining what data a variable references.
3. **Iterative Loops**: Utilizing loops like `for` and `while` for iteration.
4. **Branching Statements**: Using `if-else` to control the flow of execution.
5. **Function Declaration**: Creating functions to perform specific tasks.
6. **Exception Handling**: Managing errors with `try-catch` blocks.
7. **Data Structuring**: Organizing data into collections like arrays and objects.
8. **Algorithm Implementation**: Writing logic for sorting, searching, etc.
9. **Recursive Logic**: Functions calling themselves to solve problems.
10. **Debugging Techniques**: Using tools or strategies to fix bugs.
11. **Version Control Commands**: Using Git for source code management.
12. **RESTful Services**: Making HTTP requests to REST APIs.
13. **SQL Querying**: Writing and executing SQL commands for databases.
14. **String Pattern Matching**: Utilizing regex for string operations.
15. **Refactoring Code**: Modifying code to improve its structure.
16. **Memory Management**: Allocating and deallocating memory manually.
17. **Parallel Computing**: Using multi-threading or multi-processing.
18. **Asynchronous Code**: Writing non-blocking code with callbacks, promises, or async/await.
19. **Unit Test Writing**: Creating tests for small units of code.
20. **Integration Testing**: Validating the integration of multiple code units.
21. **Class Designing**: Crafting blueprints for objects in OOP.
22. **Casting Types**: Converting between data types explicitly.
23. **Source Compilation**: Turning code into machine-readable format.
24. **Automated Scripting**: Writing scripts to automate tasks.
25. **Code Linting**: Checking code for stylistic and programming errors.
26. **Dev Environment Configuring**: Setting up IDEs and development tools.
27. **Event Listening**: Setting up listeners for user or system events.
28. **Peer Code Reviewing**: Examining code written by others for feedback.
29. **Code Commenting**: Documenting the purpose of code segments.
30. **Library Management**: Organizing and updating code dependencies.
31. **Build Automation**: Setting up build processes with tools like Webpack or Make.
32. **Continuous Integration Setup**: Establishing pipelines for code integration.
33. **Deployment Automation**: Scripting the deployment of code to production.
34. **State Tracking**: Managing application state in various states or contexts.
35. **Dynamic Content Rendering**: Generating HTML content with JavaScript.
36. **Session Management**: Persisting user state between different requests.
37. **Socket Programming**: Creating network connections for real-time communication.
38. **Encryption Algorithms**: Applying encryption for data security.
39. **Object Serialization**: Converting objects to a format for storage or transmission.
40. **Applying Design Patterns**: Implementing Singleton, Factory, Observer, etc.
41. **Auto-generating Code**: Using tools to generate boilerplate code.
42. **Data Caching**: Storing frequently accessed data in memory.
43. **Bulk Data Processing**: Handling large datasets effectively.
44. **Middleware Writing**: Creating middleware for handling HTTP requests in frameworks.
45. **Source Minification**: Shrinking code files for production.
46. **Automated Garbage Collection**: Allowing the system to reclaim memory.
47. **ORM Integration**: Using an Object-Relational Mapper for database interactions.
48. **Template Rendering**: Combining data with templates to produce HTML.
49. **Implementing Message Queues**: Decoupling processes through message queuing systems.
50. **Parsing Data Formats**: Reading and writing JSON, XML, etc.
51. **CLI Argument Parsing**: Handling command-line inputs in scripts.
52. **Adhering to Semantic Versioning**: Following version naming conventions.
53. **Conducting Synchronous Execution**: Writing code that runs line by line.
54. **Modular Coding**: Organizing code into reusable and isolated modules.
55. **Code Concatenation**: Merging files for streamlined deployment.
56. **Custom Exception Definition**: Creating specific types of errors.
57. **String Interpolation**: Embedding expressions within strings.
58. **File System Operations**: Reading and writing files.
59. **Data Type Formatting**: Presenting data in a particular format.
60. **Mathematical Computing**: Performing complex math operations.
61. **Applying Encapsulation**: Hiding details with access modifiers.
62. **Utilizing Inheritance**: Creating a class hierarchy.
63. **Implementing Polymorphism**: Allowing objects to be interacted with as if they are instances of their parent class.
64. **Abstract Class Creation**: Defining classes that can't be instantiated.
65. **Variable Destructuring**: Extracting multiple properties from objects or arrays.
66. **Generic Programming**: Creating components that
67. **Two-way Data Binding**: Ensuring the UI and model are synchronized.
68. **Concurrency Handling**: Managing concurrent access to resources.
69. **Utilizing Dynamic Typing**: Working in languages that determine type at runtime.
70. **Employing Static Typing**: Using languages that enforce type before runtime.
71. **Defining Interfaces**: Outlining a contract for class behaviors.
72. **Higher-order Function Usage**: Functions that take or return functions.
73. **Function Currying**: Transforming a function with multiple arguments into chained single-argument functions.
74. **Lazy Loading**: Deferring initialization of objects until needed.
75. **Immutability Enforcement**: Preventing changes to data after its creation.
76. **Callback Implementing**: Passing functions to be called later.
77. **Promise Utilization**: Working with objects representing eventual completion or failure.
78. **Observable Handling**: Managing streams of data over time.
79. **Architecting MVC Applications**: Structuring apps with Model-View-Controller pattern.
80. **Repository Pattern Adoption**: Decoupling data access in applications.
81. **Singleton Pattern Utilization**: Ensuring a class has only one instance.
82. **Factory Pattern Implementation**: Creating objects without specifying their concrete classes.
83. **Middleware Chaining**: Adding multiple layers of middleware in request processing.
84. **Event-driven Architecture**: Building systems that respond to and propagate events.
85. **Functional Programming Techniques**: Focusing on pure functions and avoiding shared state.
86. **Project Scaffolding**: Generating necessary directories and files for a project.
87. **Code Preprocessing**: Transforming code before it's compiled or run.
88. **Post-processing of Code**: Applying transformations after initial processing.
89. **Dynamic Resource Loading**: Bringing in resources during runtime.
90. **Applying Code Instrumentation**: Injecting monitoring code into a program.
91. **Optimizing Queries**: Refining database queries for performance.
92. **Data Compression Techniques**: Reducing the size of data for storage and transfer.
93. **Implementing Authentication**: Verifying user identities.
94. **Managing Authorization**: Controlling access to different parts of the system.
95. **Synchronizing Data**: Keeping data in sync across platforms or devices.
96. **Transaction Management**: Handling complex operations atomically.
97. **Using Key-Value Stores**: Leveraging simple, schema-less data storage.
98. **Graph Algorithm Implementation**: Solving problems with graph structures.
99. **Analyzing Code Metrics**: Measuring code characteristics for quality.
100. **Code Decoupling Practices**: Writing code with minimal dependencies.
